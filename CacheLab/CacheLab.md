# cachelab

- [cachelab](#cachelab)
  - [准备](#准备)
  - [实验开始](#实验开始)
    - [Part A](#part-a)


## 准备

所有文件均可以从官网上直接下载：[Lab Assignments](http://csapp.cs.cmu.edu/3e/labs.html)

## 实验开始

### Part A

> 我们需要首先学会 `getopt` 这个函数

直接编译会报错：

```bash
error: implicit declaration of function ‘getopt’
```

这是因为编译参数为 `-std=c99` 导致的，这将会阻止 `GNU extension`，因此我们需要自己包含 `getopt.h` 这个头文件

[原贴](https://stackoverflow.com/questions/22575940/getopt-not-included-implicit-declaration-of-function-getopt)

该实验要求我们模拟一个高速缓存 `cache` ，我们需要先明确几个概念并且一定要理解书中对于高速缓存的过程模拟（`430` 页），不然这里很难进行

* 基本概念：

我们取最一般的情况：组相联的高速缓存。假设组 `set` 的个数为 $S=2^s$，每个组中含有 $E$ 个行 `line`。每个行可以划分为**三个部分**：有效位 `valid` 、标记位 `tag` 和高速缓存块 `block`

高速缓存块 `block` 的大小为 $B=2^b$，高速缓存块实际上是一系列对象的集合。当我们需要查找某对象的值时，首先给出该对象的地址，如果在当前**层**无法利用该地址找到对应的对象，我们需要从下一层将高速缓存块 `block` 替换上来。这里有一点很关键是：一行的实际内容就是高速缓存块，因此我们**实际上执行的是行替换**

当我们利用组索引和标记确定确定哪一行之后，我们便确定了高速缓存块，这个块中存储了很多的对象，我们利用 `b` 位的块偏移来索引这些对象

* 关于读取

我给定一个地址，我需要读该地址对应的内存字（某个对象），此时与两种情况：

* 如果命中 `hit`，那么高速缓存将直接返回该内存字
* 如果不命中 `miss`，如上面所说，我们会执行行替换，再将该内存字返回（我们再次不考虑替换策略）

* 关于写入

我们给定一个地址，我需要向该地址写入某个值

* 如果命中 `hit`，意思是指在当前层的高速缓存中，**存储了该地址对应的字的值**，那么我们直接对该地址所对应的值修改即可（我们不考虑写命中的修改方法）
* 如果不命中 `miss`，意思是指当前层的高速缓存中，**没有存储该地址对应的字的值**，我们需要执行行替换，将这个字写入（这被称为 `write-allocate`，还有一种被称为 `not-write-allocate` 的方法，直接将这个字写入到低一级的高速缓存中）

