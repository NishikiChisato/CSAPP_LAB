# Datalab

- [Datalab](#datalab)
  - [准备](#准备)
    - [文件下载](#文件下载)
    - [要求](#要求)
    - [测试](#测试)
      - [操作符测试](#操作符测试)
      - [正确性测试](#正确性测试)
  - [函数编写](#函数编写)
    - [bitXor](#bitxor)
    - [tmin](#tmin)
    - [isTmax](#istmax)
    - [addOddBits](#addoddbits)
    - [negate](#negate)
    - [isAsciiDigit](#isasciidigit)

## 准备

### 文件下载

所有文件均可以从官网上直接下载：[Lab Assignments](http://csapp.cs.cmu.edu/3e/labs.html)


### 要求

本实验要求我们补充 `bits.c` 当中的函数，使得能够通过测试

对于每个表达式，要求：

1. 整数常量 `0` 到 `255` （`0xFF`），包括 `0` 到 `255`（不允许使用大常量），例如 `0xffffffff`
2. 函数参数和局部变量（无全局变量）
3. 一元整数运算`！~`
4. 二进制整数运算 `& ^ |+ << >>`

待补充函数分为两部分：整数函数和浮点数函数

对于整数函数，要求如下：

禁止：

1. 使用任何控制结构，例如 `if`、`do while`、`for`、`switch` 等
2. 定义或使用任何宏
3. 在此文件中定义任何其他函数
4. 调用任何函数
5. 使用任何其他操作符，例如 `&&`、`||`、`-`或 `？：`
6. 使用任何形式的转型
1. 使用 `int` 以外的任何数据类型，这意味着你不能使用数组、结构或联合

假设机器：

1. 使用补码，`int` 为 `32` 位
2. 执行算术右移。
3. 如果移位量小于 `0` 或大于 `31`，有不可预测行为

对于浮点数函数，要求如下：

禁止：

1. 定义或使用任意宏
2. 在此文件中定义任何附加函数
3. 调用任意函数
4. 使用任何形式的转型
5. 使用除 `int` 或 `unsigned` 以外的任何数据类型，这意味着你不能使用数组、结构体或联合。
6. 使用任何浮点数据类型、操作或常量

### 测试

#### 操作符测试

每个函数只能使用**特定的、规定数目的操作符**

* `./dlc bits.c` 用于检查每个函数是否出现报错

* `./dlc -e bits.c` 用于检测每个函数的操作符个数

#### 正确性测试

如果需要判断函数是否正确，如果是第一次执行，首先需要生成 `btest`：

```bash
make btest
```

随后运行：

```bash
./btest
```

此后每次修改函数，都需要先清除 `btest`，然后再生成和运行：

```bash
make clean
make btest
./btest
```

直接运行 `./btest` 会检测所有函数是否通过测试，如果只想检测某个函数的话则需要带 `-f` 参数：

```bash
# 检测 foo 函数是否通过测试
./btest -f foo
```

## 函数编写

### bitXor

> 要求：使用 `~` 和 `&` 来实现异或

首先，`x ^ y` 可以表示为 `(x | ~y) & (~x | y)`

现在问题转换成用 `~` 和 `&` 来实现 `|`

我们首先写出 `&` 和 `|` 的真值表：

```
a  b  a & b   a  b  a | b
0  0    0     0  0    0
1  0    0     1  0    1
0  1    0     0  1    1
1  1    1     1  1    1
```

如果将 `~` 作用在 `(a & b)` 上，得到：
```
a b ~(a & b)
0 0     1
0 1     1
1 0     1
1 1     0
```

进一步，对 `a` 和 `b` 均取反，有：

```
a b ~(~a & ~b)
0 0      0
1 0      1
0 1      1
1 1      1
```

这个正好就是 `|` 的真值表，因此，`a | b` 等价于 `~(~a & ~b)`

答案：

```c
int bitXor(int x, int y) {
  return ~(~(x & ~y) & ~(~x & y));
}
```

### tmin

> 要求：我们需要返回 `32` 为补码的最小值

依据定义，将 `1` 左移 `31` 为即可得到

答案：

```c
int tmin(void) {
  return 1 << 31;
}
```

### isTmax

> 要求：对于 `32` 位补码数，如果 `x` 是最大值则返回 `1` ，不是则返回 `0`

我们以 `4` 位补码数举例，最大值为 `0111` ，将这个数加一得到 `1000` 

如果对 `1000` 按位取反，正好和原数相等，即：若 `x` 为最大值，有 `x == ~(x + 1)`

关于等号的判断，可以用异或加逻辑非的形式：`!(~(x + 1) ^ x)`

但有一个例外是 `-1` ，其补码表示为 `1111` ，我们发现这个数也符合我们的规定，因此需要去除 `-1` 

也就是当 `x` 为 `-1` 时返回 `0` ，当 `x` 不为 `-1` 时返回 `1`

正好可以用 `!!(x + 1)` 来进行判断

答案：

```c
int isTmax(int x) {
  return !(~(x + 1) ^ x) & !!(x + 1);
}
```

### addOddBits

> 要求：如果 `x` 的位表示（从 `0` 开始）中奇数位全为 `1` ，则返回 `1` ，否则返回 `0`

二进制中每个奇数位均为 `1` 的数为：`0xAAAAAAAA`，因此我们考虑用 `0xAA` 通过移位的形式得到

将 `0xAAAAAAAA` 按位与 `x` 的结果与 `0xAAAAAAAA` 判断是否相等即可

答案：

```c
int allOddBits(int x) {
  int op = 0xAA;
  op |= (op << 8);
  op |= (op << 16);
  return !((x & op) ^ op); 
}
```

### negate

> 要求：求出 `-x`

按照补码非的定义，$-x=\sim x + 1$

答案：

```c
int negate(int x) {
  return ~x + 1;
}
```

### isAsciiDigit

> 要求：如果 `x` 为字符 `0` 到 `9` （`ASCII` 为 `0x30` 到 `0x39` ）则返回 `1` ，否则为 `0`

